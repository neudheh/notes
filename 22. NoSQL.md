- NoSQL stands for "not only SQL", or "non SQL", and is a type of database management that is designed to handle and store large volumes of unstructured and semi-structured data
- Unlike relational databases that use tables with pre-defined schemas to store data, NoSQL uses non-relational database structures which are flexible and allow dynamic schema for unstructured data
- They can adapt to changes in data structures and are capable of scaling horizontally to handle growing amounts of data
- 4 main types of NoSQL databases exist: document, key-value, wide-column, and graph databases
## Differences between relational databases and NoSQL
### Data structure
- Relational databases have a fixed, predefined schema where data must fit into tables with specific columns and data types
- This ensures consistency, and is used for applications with stable, well-structured and predictable data requirements
---
- NoSQL databases adopt flexible data models, allowing for dynamic and non-schematic data storage
- This enables developed to insert data without a predefined schema
- They are used when data structures are undefined, not fully known in advance, or are subject to frequent changes
### Scalability
- Relational databases rely on vertical scaling
- This involves improving and adding resources, such as faster processers and more memory, to the same server to handle increased load
- These high-performance components can be expensive, and upgrades are limited by the capacity of a single machine
---
- NoSQL databases rely on horizontal scaling
- This involves adding more servers or nodes to a distributed system
- The nodes communicate with each other and distribute the load, so adding more nodes helps to increase the overall capacity
- This is a more scalable and cost-effective solution for managing a growing database and increasing database traffic
### Properties
- Relational databases rely on ACID properties (Atomicity, Consistency, Isolation, Durability)
- This helps to ensure immediate and strict consistency in the database
- SQL queries guarantee that either all or none of the changes made during a transaction are committed to the database
- They also have rules on how to handle concurrent transactions and unexpected events
**Atomicity**
- Changes in the database must be performed throughout the whole database, or not at all
**Consistency**
- A transaction (read/ write operation) must take a whole database from one consistent state to another consistent state
- E.g. the total money in the bank must remain the same at the end of a bank transfer
**Isolation**
- 
**Durability**
- 
---
- 
## Advantages of NoSQL
- 
## Applications
### SQL
- 
### NoSQL
- 
## MongoDB
- MongoDB is an open source document-oriented NoSQL database, where data is stored in documents similar to JSON objects
- Its like a dictionary in python
### Creating a database and a collection
- Start the MongoDB server, and then run the following code
```python
from pymongo import MongoClient
client = MongoClient()  # creates a client on the default host and port

db = client.get_database("Entertainment") # creates database
collection = db.get_collection("Movies") # creates collection

print(client.list_database_names()) # prints a list of database names
print(db.list_collection_names()) # prints a lsit of collection names

client.close() # close connection to the server
```
- Note that the database and collection are not actually created until a document is inserted, hence the database and collection names will not show 
### Inserting documents
```python
# all fields are not null
# _id is an id that mongo db automatically assigns, and here we customise it
collection.insert_one({"_id":1, "title": "Johnny Maths", "genre": "Comedy"}) 
# No id and genre fields
collection.insert_one({"title": "Detection"}) 
```
- If we run the code again, it will try to insert the documents again, hence we will have to comment out the codes to avoid duplicates
- We also can insert multiple documents
```Python
movies = [
		{"title":"Badman", "genre":"adventure", "year":2015},  
		{"title":"Averages", "genre":["science fiction","adventure"], "year":2017},  
		{"title":"Octopus Man", "genre":"adventure", "year":2017},  
		{"title":"Fantastic Bees", "genre":"adventure", "year":2018},  
		{"title":"Underground", "genre":"horror", "year":2014}
]

collection.insert_many(movies)
```
#### Importing from CSV file
```Python
import csv
from pymongo import MongoClient

client = MongoClient()
db = client.get_database("entertainment")
collection = db.get_collection("users")

with open("input.txt") as file: #automatically closes file after with block
	reader = csv.reader(file)
	for i in csv.reader:
		collection.insert_one({"name": i[0], "age": i[1]})
client.close()	
```
### Importing from JSON file
```Python
import json
from pymongo import MongoClient

client = MongoClient()
db = client.get_database("entertainment")
collection = db.get_collection("users")

with open("data.json") as file:
	users = json.load(file)
	collection.insert_many(users)
client.close()
```
### Searching
```python
# finds and prints the first document
print(collection.find_one())
# finds and prints all the documents in the collection
print(collection.find())
```
- We can also find documents that satisfy certain criteria using query operators

| Operator | Meaning                                      |
| -------- | -------------------------------------------- |
| $eq      | Equals to                                    |
| $gt      | Greater than                                 |
| $gte     | Greater than or equal to                     |
| $lt      | Less than                                    |
| $lte     | Less than or equal to                        |
| $ne      | Not equal to                                 |
| $in      | In a specified list                          |
| $nin     | Not in a specified list                      |
| $or      | Logical OR                                   |
| $and     | Logical AND                                  |
| $not     | Logical NOT                                  |
| $exists  | Matches documents which have the named field |
```python
# find all with a genre of adventure
print(collection.find({"genre": "adventure"}))
# find all wih a genre of adventure and a year > 2018
query = {"genre":"adventure", "year":{"$gt":2016}}
result = collection.find(query)
print(result)
# only print the title of each result
for i in result:
	print(i.get("title"))
# count the number of documents in a collection
print(collection.count_documents())
client.close()
```
### Updating
```python
# find all document with a year > 2016, and change the year to 2015
search = {"year":{"$gt":2016}}
update = {"$set":{"year": 2015}}
# update one
collection.update_one(search, update)
# update many
collection.update_many(search, update)
# remove the year field for all documents
update = {"$unset":{"year":0}}
collection.update_many({}, update)
```
- `$unset` does not need a value specified as it does not make a difference
### Removing documents
```python
# delete one
collection.delete_one({"year":2015})
# delete many
collection.delete_many({"year": 2015})
# delete the whole database
collection.delete_many({})
```
### Removing database/ collection
```python
db.drop_collection("movies")
client.drop_database("entertainment")
```